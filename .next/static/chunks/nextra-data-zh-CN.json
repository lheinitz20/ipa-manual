{"/docs/advanced/cache":{"title":"缓存","data":{"":"升级到最新版本（≥ 1.0.0）来使用该功能。\n\n在大多数情况下，你不应该直接写入缓存，这可能会导致 SWR 不可预知的行为。如果你需要手动操作一个 key，请考虑使用 SWR API。\n参见：数据更改，重置测试用例之间的缓存。\n默认情况下，SWR 使用全局缓存在所有组件之间存储和共享数据。但你也可以通过 SWRConfig 的 provider 选项来自定义这个行为。缓存 provider 旨在通过更多自定义存储启用 SWR。","缓存-provider#缓存 Provider":"缓存 provider 是类似 Map 的对象，它匹配以下 TypeScript 定义（可以从 swr 导入）：\ninterface Cache<Data> {\nget(key: string): Data | undefined\nset(key: string, value: Data): void\ndelete(key: string): void\n}\n例如，一个 JavaScript Map 实例可以直接用作 SWR 的缓存 provider。","创建缓存-provider#创建缓存 Provider":"SWRConfig 的 provider 选项接收一个返回缓存 provider 的函数。该 provider 将被 SWRConfig 范围内的所有 SWR hook 使用。例如：\nimport useSWR, { SWRConfig } from 'swr'\n\nfunction App() {\nreturn (\n<SWRConfig value={{ provider: () => new Map() }}>\n<Page/>\n</SWRConfig>\n)\n}\n<Page/> 中的所有 SWR hook 都将从该 Map 实例读取和写入。你还可以针对你的特定用例使用其他缓存 provider 实现。\n在上面的例子中，当 <App/> 组件重新挂载时，provider 也会被重新创建。缓存 provider 应该放在组件树的更高位置，或者放在渲染之外。\n\n\n\n\n当嵌套时，SWR hook 将使用上层缓存 provider。如果没有上层缓存 provider，则回退到默认 provider，即一个空 Map。\n如果使用了缓存 provider，则全局 mutate 将不适用于 <SWRConfig> 范围内的 SWR hook。请使用访问当前缓存 Provider 代替。","访问当前缓存-provider#访问当前缓存 Provider":"在 React 组件内部，你需要使用 useSWRConfig hook 来访问当前缓存 provider 以及其他配置，包括 mutate：\nimport { useSWRConfig } from 'swr'\n\nfunction Avatar() {\nconst { cache, mutate, ...extraConfig } = useSWRConfig()\n// ...\n}\n如果不在任何 <SWRConfig> 中，将返回默认配置。","实验性扩展缓存-provider#实验性：扩展缓存 provider":"这是一个实验性的功能，在未来的升级中可能会发生变化。\n当多个 <SWRConfig> 组件嵌套时，可以扩展缓存 provider。provider 函数的第一个参数是上层 <SWRConfig> 的缓存 provider（如果没有父级 <SWRConfig>，则为默认缓存），你可以使用它来扩展缓存 provider：\n<SWRConfig value={{ provider: (cache) => newCache }}>\n...\n</SWRConfig>","示例#示例":"","根据正则更改多个-key#根据正则更改多个 Key":"借助缓存 provider API 的灵活性，你甚至可以构建一个“部分更改”的助手函数。在下面的示例中，matchMutate 可以接收一个正则表达式作为 key，并用于更改匹配该模式的。\nfunction useMatchMutate() {\nconst { cache, mutate } = useSWRConfig()\nreturn (matcher, ...args) => {\nif (!(cache instanceof Map)) {\nthrow new Error('matchMutate requires the cache provider to be a Map instance')\n}\n\nconst keys = []\n\nfor (const key of cache.keys()) {\nif (matcher.test(key)) {\nkeys.push(key)\n}\n}\n\nconst mutations = keys.map((key) => mutate(key, ...args))\nreturn Promise.all(mutations)\n}\n}\n在你的组件内：\nfunction Button() {\nconst matchMutate = useMatchMutate()\nreturn <button onClick={() => matchMutate(/^\\/api\\//)}>\n重新请求所有以 `/api/` 开头的 key\n</button>\n}\n\n注意，该示例要求缓存 provider 为 Map 实例。","基于-localstorage-的持久缓存#基于 LocalStorage 的持久缓存":"你可能希望将缓存同步到 localStorage。下面是一个示例实现：\nfunction localStorageProvider() {\n// 初始化时，我们将数据从 `localStorage` 恢复到一个 map 中。\nconst map = new Map(JSON.parse(localStorage.getItem('app-cache') || '[]'))\n\n// 在卸载 app 之前，我们将所有数据写回 `localStorage` 中。\nwindow.addEventListener('beforeunload', () => {\nconst appCache = JSON.stringify(Array.from(map.entries()))\nlocalStorage.setItem('app-cache', appCache)\n})\n\n// 我们仍然使用 map 进行读写以提高性能。\nreturn map\n}\n然后将其作为 provider 使用：\n<SWRConfig value={{ provider: localStorageProvider }}>\n<App/>\n</SWRConfig>\n\n作为一种改进，你还可以使用内存缓存作为缓冲区，并定期写入 localStorage。你还可以使用 IndexedDB 或 WebSQL 实现类似的分层缓存。","重置测试用例之间的缓存#重置测试用例之间的缓存":"在测试应用程序时，你可能希望重置测试用例之间的 SWR 缓存。你可以简单地使用空缓存 provider 包装你的应用程序。下面是一个使用 Jest 的例子：\ndescribe('test suite', async () => {\nit('test case', async () => {\nrender(\n<SWRConfig value={{ provider: () => new Map() }}>\n<App/>\n</SWRConfig>\n)\n})\n})","访问缓存#访问缓存":"警告：你不应该直接写入缓存，那样可能会导致不可预知的行为。\nconst { cache } = useSWRConfig()\n\ncache.get(key) // 获取 key 的当前数据。\ncache.clear()  // ⚠️ 清除所有缓存。SWR 将在重新渲染时重新请求。"}},"/docs/advanced/performance":{"title":"性能","data":{"":"SWR 在各种 web 应用中提供了关键功能，因此 性能 是重中之重。SWR 内置的 缓存 和 重复请求去除 会跳过不必要的网络请求，但 useSWR hook 本身的性能仍然很重要。在一个复杂的应用中，单个页面渲染可能会调用数百次 useSWR。SWR 确保你的应用具有：\n没有不必要的请求\n没有不必要的重新渲染\n没有不必要的代码导入\n\n而无需你更改任何代码。","重复数据删除#重复数据删除":"在应用中重用 SWR hooks 非常常见。例如，一个应用渲染 5 次当前用户的头像：\nfunction useUser () {\nreturn useSWR('/api/user', fetcher)\n}\n\nfunction Avatar () {\nconst { data, error } = useUser()\n\nif (error) return <Error />\nif (!data) return <Spinner />\n\nreturn <img src={data.avatar_url} />\n}\n\nfunction App () {\nreturn <>\n<Avatar />\n<Avatar />\n<Avatar />\n<Avatar />\n<Avatar />\n</>\n}\n每个 <Avatar> 组件内部都有一个 useSWR hook。由于它们具有相同的 SWR key，并且几乎同时渲染，因此 只会发送 1 个网络请求。你可以在任何地方重用数据 hooks（比如上面示例中的 useUser），而不用担心性能或重复请求。还有一个 dedupingInterval 选项 用于覆盖默认的重复数据删除间隔。","深度比较#深度比较":"SWR 默认 深度比较 数据更改。如果 data 值没有改变，则不会触发重新渲染。如果你还想更改的话，可以通过 compare 选项 自定义比较函数。比如，某些 API 响应返回一个服务器时间戳，你可能想从数据 diff 中排除它。","依赖收集#依赖收集":"useSWR 返回 3 个 有状态的 值：data、error 和 isValidating，每个都可以独立更新。例如，如果我们在一个完整的数据请求生命周期中打印这些值，则将如下所示：\nfunction App () {\nconst { data, error, isValidating } = useSWR('/api', fetcher)\nconsole.log(data, error, isValidating)\nreturn null\n}\n在最坏的情况下（第一个请求失败，然后重试成功），你将看到 4 行日志：\n// console.log(data, error, isValidating)\nundefined undefined true  // => 开始 fetching\nundefined Error false     // => 结束 fetching，出现错误\nundefined Error true      // => 开始重试\nData undefined false      // => 重试结束，得到数据\n状态的改变是有道理的。但这也意味着组件 渲染了 4 次。如果我们将组件更改为只使用 data：\nfunction App () {\nconst { data } = useSWR('/api', fetcher)\nconsole.log(data)\nreturn null\n}\n神奇的事情发生了 - 现在只有 2 次重新渲染：\n// console.log(data)\nundefined // => hydration / 初始渲染\nData      // => 重试结束，得到数据\n内部发生了完全相同的过程，第一个请求出现了错误，然后我们重试得到了数据。但是，SWR 只更新了组件使用的状态，即：data。如果你不是总使用这3种状态，那么你已经从这个特性中获益了。在 Vercel 的实际应用中，这个优化减少了约 60% 的重新渲染。","tree-shaking#Tree Shaking":"SWR 满足 tree-shakeable 且没有副作用。这意味着如果你只导入核心的 useSWR API，像 useSWRInfinite 这样的未使用的 API 将不会绑定到你的应用中。"}},"/docs/advanced/react-native":{"title":"React Native","data":{"":"升级到最新版本（≥ 1.0.0）来体验该定制。\n与在浏览器中运行的 React 不同，React Native 有着非常不同的使用体验。比如没有“标签聚焦”，而从后台切换到 app 则被视为“聚焦”。要想自定义这些行为，你可以使用 React Native 的 app 状态检测和其他原生移植 API 替换默认的 focus 和 online，并配置 SWR 来使用。","示例#示例":"","全局设置#全局设置":"你可以将 app 包装在 SWRConfig 下并预设置所有配置\n<SWRConfig\nvalue={{\n/* ... */\n}}\n>\n<App>\n</SWRConfig>","自定义-focus-和-reconnect-事件#自定义 focus 和 reconnect 事件":"只有很少的的配置需要你来处理，诸如 isOnline、isVisible、initFocus 以及 initReconnect。isOnline 和 isVisible 是两个返回布尔值的函数，它们用来确定应用程序是否是 \"active\" 的。默认情况下，如果不满足这些条件，SWR 将取消重新请求。在使用 initFocus 和 initReconnect 时，还需要设置一个自定义缓存 provider。可以使用空的 Map() 或任何你喜欢的。\n<SWRConfig\nvalue={{\nprovider: () => new Map(),\nisOnline() {\n/* 自定义网络状态检测器 */\nreturn true\n},\nisVisible() {\n/* 自定义 visibility 状态检测器 */\nreturn true\n},\ninitFocus(callback) {\n/* 向状态 provider 注册侦听器 */\n},\ninitReconnect(callback) {\n/* 向状态 provider 注册侦听器 */\n}\n}}\n>\n<App />\n</SWRConfig>\n以 initFocus 为例：\nimport { AppState } from 'react-native'\n\n// ...\n\n<SWRConfig\nvalue={{\nprovider: () => new Map(),\nisVisible: () => { return true },\ninitFocus(callback) {\nlet appState = AppState.currentState\n\nconst onAppStateChange = (nextAppState) => {\n/* 如果正在从后台或非 active 模式恢复到 active 模式 */\nif (appState.match(/inactive|background/) && nextAppState === 'active') {\ncallback()\n}\nappState = nextAppState\n}\n\n// 订阅 app 状态更改事件\nconst subscription = AppState.addEventListener('change', onAppStateChange)\n\nreturn () => {\nsubscription.remove()\n}\n}\n}}\n>\n<App>\n</SWRConfig>\n关于 initReconnect，它需要第三方库例如 NetInfo 来订阅网络状态。具体实现和上面的例子类似：接收 callback 函数并在网络从离线状态恢复时触发它，然后 SWR 会启动重新请求以确保数据始终是最新的。"}},"/examples/auth":{"title":"身份验证","data":{"":""}},"/examples/basic":{"title":"基本用法","data":{"":""}},"/examples/error-handling":{"title":"错误处理","data":{"":""}},"/examples/infinite-loading":{"title":"无限加载","data":{"":""}}}
{"/docs/advanced/cache":{"title":"Кеш","data":{"":"Обновитесь до последней версии (≥ 1.0.0), чтобы использовать этот функционал.\n\nВ большинстве случаев вы не должны напрямую писать в кеш, поскольку это может вызвать\nнеопределенное поведение SWR. Если вам нужно вручную изменить ключ, рассмотрите возможность\nиспользования API SWR.\nСм. также: Мутация, Сброс кеша между тестами.\nПо умолчанию SWR использует глобальный кеш для хранения и обмена данными между всеми компонентами.\nНо вы также можете настроить это поведение с помощью опции provider в SWRConfig.Провайдеры кеша предназначены для включения SWR с более индивидуализированными хранилищами.","провайдер-кеша#Провайдер кеша":"Поставщик кеша — это объект типа Map, который соответствует следующему определению TypeScript\n(которое может быть импортировано из swr):\ninterface Cache<Data> {\nget(key: string): Data | undefined\nset(key: string, value: Data): void\ndelete(key: string): void\n}\nНапример, экземпляр JavaScript Map\nможно напрямую использовать в качестве провайдера кеша для SWR.","создание-провайдера-кеша#Создание провайдера кеша":"Опция provider в SWRConfig получает функцию, которая возвращает провайдер кеша.\nЗатем провайдер будет использоваться всеми хуками SWR в пределах SWRConfig. Например:\nimport useSWR, { SWRConfig } from 'swr'\n\nfunction App() {\nreturn (\n<SWRConfig value={{ provider: () => new Map() }}>\n<Page/>\n</SWRConfig>\n)\n}\nВсе хуки SWR внутри <Page/> будут читать и писать из этого экземпляра Map. Вы также можете использовать\nдругие реализации поставщика кеша для вашего конкретного случая использования.\nВ приведённом выше примере, когда компонент <App /> повторно монтируется, провайдер также будет\nповторно создан. Провайдеры кеша должны быть размещены выше в дереве компонентов или вне рендеринга.\n\n\n\n\nПри вложенности, хуки SWR будут использовать провайдер кеша верхнего уровня. Если нет провайдера кеша\nверхнего уровня, он возвращается к провайдеру кэша по умолчанию, который является пустым Map.\nЕсли используется провайдер кеша, глобальный mutate не будет работать для хуков SWR в пределе\nэтого <SWRConfig>. Пожалуйста, используйте это взамен.","доступ-к-текущему-провайдеру-кеша#Доступ к текущему провайдеру кеша":"Находясь внутри компонента React, вам нужно использовать хук useSWRConfig,\nчтобы получить доступ к текущему провайдеру кеша, а также к другим конфигурациям, включая mutate:\nimport { useSWRConfig } from 'swr'\n\nfunction Avatar() {\nconst { cache, mutate, ...extraConfig } = useSWRConfig()\n// ...\n}\nЕсли он не находится под каким-либо <SWRConfig>, он вернет конфигурации по умолчанию.","экспериментально-расширение-провайдера-кеша#Экспериментально: Расширение провайдера кеша":"Это экспериментальный функционал, его поведение может измениться в будущих обновлениях.\nКогда несколько компонентов <SWRConfig> вложены, провайдер кеша может быть расширен.Первым аргументом для функции provider является поставщик кеша верхнего уровня <SWRConfig>\n(или кеш по умолчанию, если нет родительского <SWRConfig>),\nвы можете использовать его для расширения провайдера кеша:\n<SWRConfig value={{ provider: (cache) => newCache }}>\n...\n</SWRConfig>","примеры#Примеры":"","мутация-множества-ключей-из-регулярных-выражений-regex#Мутация множества ключей из регулярных выражений (RegEx)":"Благодаря гибкости API кеш-провайдера вы даже можете создать помощник «частичной мутации».В приведенном ниже примере matchMutate может принимать регулярное выражение в качестве ключа\nи использоваться для мутации тех, кто соответствует этому шаблону.\nfunction useMatchMutate() {\nconst { cache, mutate } = useSWRConfig()\nreturn (matcher, ...args) => {\nif (!(cache instanceof Map)) {\nthrow new Error('matchMutate требует, чтобы провайдер кеша был экземпляром Map')\n}\n\nconst keys = []\n\nfor (const key of cache.keys()) {\nif (matcher.test(key)) {\nkeys.push(key)\n}\n}\n\nconst mutations = keys.map((key) => mutate(key, ...args))\nreturn Promise.all(mutations)\n}\n}\nЗатем внутри вашего компонента:\nfunction Button() {\nconst matchMutate = useMatchMutate()\nreturn <button onClick={() => matchMutate(/^\\/api\\//)}>\nРевалидировать все ключи, начинающиеся на \"/api/\"\n</button>\n}\n\nОбратите внимание, что данный пример требует, чтобы провайдер кеша был экземпляром Map.","постоянный-кеш-на-основе-localstorage#Постоянный кеш на основе LocalStorage":"Возможно, вы захотите синхронизировать свой кеш с localStorage. Вот пример реализации:\nfunction localStorageProvider() {\n// При инициализации мы восстанавливаем данные из `localStorage` в Map.\nconst map = new Map(JSON.parse(localStorage.getItem('app-cache') || '[]'))\n\n// Перед выгрузкой приложения мы записываем все данные обратно в `localStorage`.\nwindow.addEventListener('beforeunload', () => {\nconst appCache = JSON.stringify(Array.from(map.entries()))\nlocalStorage.setItem('app-cache', appCache)\n})\n\n// Мы по-прежнему используем map для записи и чтения для производительности.\nreturn map\n}\nЗатем используйте его как провайдер:\n<SWRConfig value={{ provider: localStorageProvider }}>\n<App/>\n</SWRConfig>\n\nВ качестве улучшения вы также можете использовать кеш памяти в качестве буфера и периодически\nзаписывать в localStorage. Вы также можете реализовать аналогичный многоуровневый кеш\nс помощью IndexedDB или WebSQL.","сброс-кеша-между-тестами#Сброс кеша между тестами":"При тестировании приложения вы можете сбросить кеш SWR между тестами. Вы можете просто обернуть\nваше приложение пустым провайдером кеша. Вот пример с Jest:\ndescribe('тестирование', async () => {\nit('тестовый пример', async () => {\nrender(\n<SWRConfig value={{ provider: () => new Map() }}>\n<App/>\n</SWRConfig>\n)\n})\n})","доступ-к-кешу#Доступ к кешу":"Предупреждение: вы не должны писать в кеш напрямую, это может привести к неопределенному поведению.\nconst { cache } = useSWRConfig()\n\ncache.get(key) // Получить текущие данные для ключа.\ncache.clear()  // ⚠️ Очистить весь кеш. SWR проведёт ревалидацию при повторном рендеринге."}},"/docs/advanced/performance":{"title":"Производительность","data":{"":"SWR обеспечивает критически важную функциональность во всех видах веб-приложений, поэтому\nпроизводительность является главным приоритетом.Встроенное кеширование и дедупликация SWR пропускают ненужные сетевые запросы,\nно производительность самого хука useSWR всё ещё имеет значение. В сложном приложении могут быть сотни\nвызовов useSWR при отрисовке одной страницы.SWR гарантирует, что в вашем приложении:\nнет лишних запросов\nнет лишних повторных рендеров\nне импортируется ненужный код\n\nбез каких-либо изменений кода с вашей стороны.","дедупликация#Дедупликация":"Хуки SWR зачастую используются в приложении повторно. Например, приложение, которое рендерит\nаватар текущего пользователя 5 раз:\nfunction useUser () {\nreturn useSWR('/api/user', fetcher)\n}\n\nfunction Avatar () {\nconst { data, error } = useUser()\n\nif (error) return <Error />\nif (!data) return <Spinner />\n\nreturn <img src={data.avatar_url} />\n}\n\nfunction App () {\nreturn <>\n<Avatar />\n<Avatar />\n<Avatar />\n<Avatar />\n<Avatar />\n</>\n}\nКаждый компонент <Avatar> имеет внутри хук useSWR. Поскольку они имеют одинаковый ключ SWR\nи рендерятся почти одновременно, будет выполнен только 1 сетевой запрос.Вы можете повторно использовать свои хуки данных (например, useUser в приведенном выше примере) повсюду,\nне беспокоясь о производительности или дублировании запросов.Существует также опция dedupingInterval для переопределения интервала дедупликации\nпо умолчанию.","глубокое-сравнение#Глубокое сравнение":"SWR глубоко сравнивает изменения данных по умолчанию. Если значение data не изменилось,\nповторный рендеринг запускаться не будет.Вы также можете настроить функцию сравнения с помощью опции compare, если хотите\nизменить поведение. Например, некоторые ответы API возвращают отметку времени сервера, которую вы,\nвозможно, захотите исключить из сравнения данных.","коллекция-зависимостей#Коллекция зависимостей":"useSWR возвращает 3 значения с сохранением состояния: data, error и isValidating,\nкаждое из которых может обновляться независимо. Например, если мы выведим эти значения внутри\nполного жизненного цикла выборки данных, это будет примерно так:\nfunction App () {\nconst { data, error, isValidating } = useSWR('/api', fetcher)\nconsole.log(data, error, isValidating)\nreturn null\n}\nВ худшем случае (первый запрос не удался, затем повторная попытка была успешной) вы увидите 4 строки журнала:\n// console.log(data, error, isValidating)\nundefined undefined true  // => начало выборки\nundefined Error false     // => конец выборки, получили ошибку\nundefined Error true      // => начало повторной попытки\nData undefined false      // => конец повторной попытки, получение данных\nИзменения состояния имеют смысл. Но это также означает, что наш компонент рендерился 4 раза.Если мы изменим наш компонент на использование только data:\nfunction App () {\nconst { data } = useSWR('/api', fetcher)\nconsole.log(data)\nreturn null\n}\nВолшебство происходит — теперь всего 2 рендера:\n// console.log(data)\nundefined // => гидратация / начальный рендер\nData      // => конец повторной попытки, получение данных\nТочно такой же процесс произошёл внутри, возникла ошибка при первом запросе, затем мы получили данные\nпри повторной попытке. Однако SWR обновляет только состояния, которые используются компонентом,\nкоторым сейчас является только data.Если вы не всегда используете все эти 3 состояния, вы уже извлекаете пользу из этого функционала.\nВ Vercel эта оптимизация приводит к сокращению повторного рендеринга примерно на 60%.","встряхивание-tree-shaking#Встряхивание (Tree Shaking)":"Пакет SWR легко встряхивается и не имеет побочных эффектов\n(side-effects). Это означает, что если вы импортируете только основной API useSWR, неиспользуемые API,\nтакие как useSWRInfinite, не будут включены в ваше приложение."}},"/docs/advanced/react-native":{"title":"React Native","data":{"":"Обновитесь до последней версии (≥ 1.0.0), чтобы испытать эту настройку.\nВ отличие от React, работающего внутри браузеров, React Native имеет совсем другой опыт использования.\nНапример, нет «фокуса вкладки», вместо этого переключение с фона на приложение рассматривается как «фокус».\nЧтобы настроить это поведение, вы можете заменить стандартные прослушиватели событий focus и online\nв браузере на детекторы состояния приложения React Native и другие портированные нативные API,\nа также настроить SWR для их использования.","пример#Пример":"","глобальная-настройка#Глобальная настройка":"Вы можете обернуть своё приложение в SWRConfig и предварительно сконфигурировать все конфигурации там\n<SWRConfig\nvalue={{\n/* ... */\n}}\n>\n<App>\n</SWRConfig>","настроить-события-focus-и-reconnect#Настроить события focus и reconnect":"Вам нужно позаботиться о нескольких конфигурациях, таких как isOnline, isVisible, initFocus и initReconnect.isOnline и isVisible — это функции, которые возвращают логическое значение, чтобы определить,\nявляется ли приложение «активным». По умолчанию SWR придёт на помощь сделав повторную валидацию,\nесли эти условия не выполняются.При использовании initFocus и initReconnect необходимо также настроить кастомный провайдер кеша.\nВы можете использовать пустой Map() или любое другое хранилище, которое вам нравится.\n<SWRConfig\nvalue={{\nprovider: () => new Map(),\nisOnline() {\n/* Настройте детектор состояния сети */\nreturn true\n},\nisVisible() {\n/* Настройте детектор состояния видимости */\nreturn true\n},\ninitFocus(callback) {\n/* Зарегистрируйте слушатель в провайдере состояния */\n},\ninitReconnect(callback) {\n/* Зарегистрируйте слушатель в провайдере состояния */\n}\n}}\n>\n<App />\n</SWRConfig>\nРассмотрим пример initFocus:\nimport { AppState } from 'react-native'\n\n// ...\n\n<SWRConfig\nvalue={{\nprovider: () => new Map(),\nisVisible: () => { return true },\ninitFocus(callback) {\nlet appState = AppState.currentState\n\nconst onAppStateChange = (nextAppState) => {\n/* Если оно переходит из фонового или неактивного режима в активный */\nif (appState.match(/inactive|background/) && nextAppState === 'active') {\ncallback()\n}\nappState = nextAppState\n}\n\n// Подпишитесь на события изменения состояния приложения\nconst subscription = AppState.addEventListener('change', onAppStateChange)\n\nreturn () => {\nsubscription.remove()\n}\n}\n}}\n>\n<App>\n</SWRConfig>\nДля initReconnect требуется, чтобы некоторые сторонние библиотеки, такие как\nNetInfo, подписывались на статус сети.\nРеализация будет аналогична приведенному выше примеру: получение функции callback и её запуск,\nкогда сеть выходит из автономного режима, чтобы SWR смог начать ревалидацию, чтобы поддерживать\nваши данные в актуальном состоянии."}},"/examples/auth":{"title":"Аутентификация","data":{"":""}},"/examples/basic":{"title":"Основное использование","data":{"":""}},"/examples/error-handling":{"title":"Обработка ошибок","data":{"":""}},"/examples/infinite-loading":{"title":"Бесконечная загрузка","data":{"":""}},"/examples/ssr":{"title":"Next.js SSR","data":{"":""}}}
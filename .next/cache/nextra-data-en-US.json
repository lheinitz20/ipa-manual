{"/":{"title":"Introduction","data":{"":"Welcome\nHier findest du meine Notizen, Tipps und Tricks zur Portfolio-Animation.In diesem Handbuch wird dir kurz und bündig erklärt, wie der Quellcode der Animation aufgebaut ist, was du wie anpassen kannst und wovon du besser die Finger lässt :)Ich hoffe du findest wonach du suchst!\nDu kannst dir das Ganze Projekt über GitHub herunterladen, entpacken und auch starten. Wie das funktioniert erkläre ich dir im Handbuch.\n\nInstallation · Beispiele · GitHub Repository"}},"/docs/installation":{"title":"Installation","data":{"":""}},"/docs/configuration":{"title":"Configuration","data":{"":""}},"/docs/advanced/cache":{"title":"Cache","data":{"":"Upgrade to the latest version (≥ 1.0.0) to use this feature.\n\nIn most cases, you shouldn't directly write to the cache, which might cause undefined behaviors of SWR. If you need to manually mutate a key, please consider using the SWR APIs.\nSee also: Mutation, Reset Cache Between Test Cases.\nBy default, SWR uses a global cache to store and share data across all components. But you can also customize this behavior with the provider option of SWRConfig.Cache providers are intended to enable SWR with more customized storages.","cache-provider#Cache Provider":"A cache provider is Map-like object which matches the following TypeScript definition (which can be imported from swr):\ninterface Cache<Data> {\nget(key: string): Data | undefined\nset(key: string, value: Data): void\ndelete(key: string): void\n}\nFor example, a JavaScript Map instance can be directly used as the cache provider for SWR.","create-cache-provider#Create Cache Provider":"The provider option of SWRConfig receives a function that returns a cache provider. The provider will then be used by all SWR hooks inside that SWRConfig boundary. For example:\nimport useSWR, { SWRConfig } from 'swr'\n\nfunction App() {\nreturn (\n<SWRConfig value={{ provider: () => new Map() }}>\n<Page/>\n</SWRConfig>\n)\n}\nAll SWR hooks inside <Page/> will read and write from that Map instance. You can also use other cache provider implementations as well for your specific use case.\nIn the example above, when the <App/> component is re-mounted, the provider will also be re-created. Cache providers should be put higher in the component tree, or outside of render.\n\n\n\n\nWhen nested, SWR hooks will use the upper-level cache provider. If there is no upper-level cache provider, it fallbacks to the default cache provider, which is an empty Map.\nIf a cache provider is used, the global mutate will not work for SWR hooks under that <SWRConfig> boundary. Please use this instead.","access-current-cache-provider#Access Current Cache Provider":"When inside a React component, you need to use the useSWRConfig hook to get access to the current cache provider as well as other configurations including mutate:\nimport { useSWRConfig } from 'swr'\n\nfunction Avatar() {\nconst { cache, mutate, ...extraConfig } = useSWRConfig()\n// ...\n}\nIf it's not under any <SWRConfig>, it will return the default configurations.","experimental-extend-cache-provider#Experimental: Extend Cache Provider":"This is an experimental feature, the behavior might change in future upgrades.\nWhen multiple <SWRConfig> components are nested, cache provider can be extended.The first argument for the provider function is the cache provider of the upper-level <SWRConfig> (or the default cache if there's no parent <SWRConfig>), you can use it to extend the cache provider:\n<SWRConfig value={{ provider: (cache) => newCache }}>\n...\n</SWRConfig>","examples#Examples":"","mutate-multiple-keys-from-regex#Mutate Multiple Keys from RegEx":"With the flexibility of the cache provider API, you can even build a \"partial mutation\" helper.In the example below, matchMutate can receive a regex expression as key, and be used to mutate the ones who matched this pattern.\nfunction useMatchMutate() {\nconst { cache, mutate } = useSWRConfig()\nreturn (matcher, ...args) => {\nif (!(cache instanceof Map)) {\nthrow new Error('matchMutate requires the cache provider to be a Map instance')\n}\n\nconst keys = []\n\nfor (const key of cache.keys()) {\nif (matcher.test(key)) {\nkeys.push(key)\n}\n}\n\nconst mutations = keys.map((key) => mutate(key, ...args))\nreturn Promise.all(mutations)\n}\n}\nThen inside your component:\nfunction Button() {\nconst matchMutate = useMatchMutate()\nreturn <button onClick={() => matchMutate(/^\\/api\\//)}>\nRevalidate all keys start with \"/api/\"\n</button>\n}\n\nNote that this example requires the cache provider to be a Map instance.","localstorage-based-persistent-cache#LocalStorage Based Persistent Cache":"You might want to sync your cache to localStorage. Here's an example implementation:\nfunction localStorageProvider() {\n// When initializing, we restore the data from `localStorage` into a map.\nconst map = new Map(JSON.parse(localStorage.getItem('app-cache') || '[]'))\n\n// Before unloading the app, we write back all the data into `localStorage`.\nwindow.addEventListener('beforeunload', () => {\nconst appCache = JSON.stringify(Array.from(map.entries()))\nlocalStorage.setItem('app-cache', appCache)\n})\n\n// We still use the map for write & read for performance.\nreturn map\n}\nThen use it as a provider:\n<SWRConfig value={{ provider: localStorageProvider }}>\n<App/>\n</SWRConfig>\n\nAs an improvement, you can also use the memory cache as a buffer, and write to localStorage periodically. You can also implement a similar layered cache with IndexedDB or WebSQL.","reset-cache-between-test-cases#Reset Cache Between Test Cases":"When testing your application, you might want to reset the SWR cache between test cases. You can simply wrap your application with an empty cache provider. Here's an example with Jest:\ndescribe('test suite', async () => {\nit('test case', async () => {\nrender(\n<SWRConfig value={{ provider: () => new Map() }}>\n<App/>\n</SWRConfig>\n)\n})\n})","access-to-the-cache#Access to the Cache":"Alert: you should not write to the cache directly, it might cause undefined behavior.\nconst { cache } = useSWRConfig()\n\ncache.get(key) // Get the current data for a key.\ncache.clear()  // ⚠️ Clear all the cache. SWR will revalidate upon re-render."}},"/docs/advanced/performance":{"title":"Performance","data":{"":"SWR provides critical functionality in all kinds of web apps, so performance is a top priority.SWR’s built-in caching and deduplication skips unnecessary network requests, but\nthe performance of the useSWR hook itself still matters. In a complex app, there could be hundreds of useSWR calls in a single page render.SWR ensures that your app has:\nno unnecessary requests\nno unnecessary re-renders\nno unnecessary code imported\n\nwithout any code changes from you.","deduplication#Deduplication":"It’s very common to reuse SWR hooks in your app. For example, an app that renders the current user’s avatar 5 times:\nfunction useUser () {\nreturn useSWR('/api/user', fetcher)\n}\n\nfunction Avatar () {\nconst { data, error } = useUser()\n\nif (error) return <Error />\nif (!data) return <Spinner />\n\nreturn <img src={data.avatar_url} />\n}\n\nfunction App () {\nreturn <>\n<Avatar />\n<Avatar />\n<Avatar />\n<Avatar />\n<Avatar />\n</>\n}\nEach <Avatar> component has a useSWR hook inside. Since they have the same SWR key and are rendered almost at the same time, only 1 network request will be made.You can reuse your data hooks (like useUser in the example above) everywhere, without worrying about performance or duplicated requests.There is also a dedupingInterval option for overriding the default deduplication interval.","deep-comparison#Deep Comparison":"SWR deep compares data changes by default. If the data value isn’t changed, a re-render will not be triggered.You can also customize the comparison function via the compare option if you want to change the behavior.\nFor example, some API responses return a server timestamp that you might want to exclude from the data diff.","dependency-collection#Dependency Collection":"useSWR returns 3 stateful values: data, error and isValidating, each one can be updated independently.\nFor example, if we print those values within a full data-fetching lifecycle, it will be something like this:\nfunction App () {\nconst { data, error, isValidating } = useSWR('/api', fetcher)\nconsole.log(data, error, isValidating)\nreturn null\n}\nIn the worst case (the first request failed, then the retry was successful), you will see 4 lines of logs:\n// console.log(data, error, isValidating)\nundefined undefined true  // => start fetching\nundefined Error false     // => end fetching, got an error\nundefined Error true      // => start retrying\nData undefined false      // => end retrying, get the data\nThe state changes make sense. But that also means our component rendered 4 times.If we change our component to only use data:\nfunction App () {\nconst { data } = useSWR('/api', fetcher)\nconsole.log(data)\nreturn null\n}\nThe magic happens — there are only 2 re-renders now:\n// console.log(data)\nundefined // => hydration / initial render\nData      // => end retrying, get the data\nThe exact same process has happened internally, there was an error from the first request, then we got the data from the retry.\nHowever, SWR only updates the states that are used by the component, which is only data now.If you are not always using all these 3 states, you are already benefitting from this feature.\nAt Vercel, this optimization results in ~60% fewer re-renders.","tree-shaking#Tree Shaking":"The SWR package is tree-shakeable and side-effect free.\nThat means if you are only importing the core useSWR API, unused APIs like useSWRInfinite won't be bundled in your application."}},"/docs/advanced/react-native":{"title":"React Native","data":{"":"Upgrade to the latest version (≥ 1.0.0) to experience this customization.\nUnlike React running inside the browsers, React Native has a very different user experience. For example there is no “tab focus”, switching from the background to the app is considered as a “focus” instead.\nTo customize these behaviors, you can replace the default browser focus and online events listeners with React Native’s app state detection and other native ported API, and configure SWR to use them.","example#Example":"","global-setup#Global Setup":"You can wrap your app under SWRConfig and preconfig all configurations there\n<SWRConfig\nvalue={{\n/* ... */\n}}\n>\n<App>\n</SWRConfig>","customize-focus-and-reconnect-events#Customize focus and reconnect Events":"There're few configurations you need to take care of such as isOnline, isVisible, initFocus and initReconnect.isOnline and isVisible are functions that return a boolean, to determine if the application is \"active\". By default, SWR will bail out a revalidation if these conditions are not met.When using initFocus and initReconnect, it's required to also set up a custom cache provider. You can use an empty Map() or any storage you prefer.\n<SWRConfig\nvalue={{\nprovider: () => new Map(),\nisOnline() {\n/* Customize the network state detector */\nreturn true\n},\nisVisible() {\n/* Customize the visibility state detector */\nreturn true\n},\ninitFocus(callback) {\n/* Register the listener with your state provider */\n},\ninitReconnect(callback) {\n/* Register the listener with your state provider */\n}\n}}\n>\n<App />\n</SWRConfig>\nLet's take initFocus as example:\nimport { AppState } from 'react-native'\n\n// ...\n\n<SWRConfig\nvalue={{\nprovider: () => new Map(),\nisVisible: () => { return true },\ninitFocus(callback) {\nlet appState = AppState.currentState\n\nconst onAppStateChange = (nextAppState) => {\n/* If it's resuming from background or inactive mode to active one */\nif (appState.match(/inactive|background/) && nextAppState === 'active') {\ncallback()\n}\nappState = nextAppState\n}\n\n// Subscribe to the app state change events\nconst subscription = AppState.addEventListener('change', onAppStateChange)\n\nreturn () => {\nsubscription.remove()\n}\n}\n}}\n>\n<App>\n</SWRConfig>\nFor initReconnect, it requires some 3rd party libraries such as NetInfo to subscribe to the network status. The implementation will be similar to the example above: receiving a callback function and trigger it when the network recovers from offline, so SWR can start a revalidation to keep your data up-to-date."}},"/examples/auth":{"title":"auth","data":{"":""}},"/examples/basic":{"title":"basic","data":{"":""}},"/examples/error-handling":{"title":"error-handling","data":{"":""}},"/examples/infinite-loading":{"title":"Infinite Loading","data":{"":""}},"/examples/optimistic-ui":{"title":"Optimistic UI","data":{"":""}},"/examples/ssr":{"title":"Next.js SSR","data":{"":""}},"/docs/adjustments":{"title":"Adjustments","data":{"":""}},"/examples/svg-colors":{"title":"SVG Color Adjustment","data":{"":""}},"/animation":{"title":"Animation","data":{"":""}},"/docs/adjustments/svgelements":{"title":"svgelements","data":{"":""}}}
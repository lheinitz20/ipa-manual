{"/docs/advanced/cache":{"title":"캐시","data":{"":"이 기능을 사용하시려면 최신 버전(≥ 1.0.0)으로 업그레이드하세요.\n\n대부분의 경우에 캐시를 직접 _작성_하면 안 됩니다. 이는 SWR에 정의되지 않은 동작을 유발할 수 있습니다. 수동으로 키를 변경해야 하는 경우 SWR APIs 사용을 고려해 주세요.\n여기도 확인해보세요: 뮤테이션, 테스트 케이스 간 캐시 초기화.\n기본적으로 SWR은 전역 캐시를 사용해 모든 컴포넌트 사이에 데이터를 저장하고 공유합니다. 하지만 SWRConfig의 provider 옵션으로 이 동작을 커스터마이징 할 수도 있습니다.캐시 공급자는 더 맞춤화된 저장소로 SWR을 활성화하기 위한 것입니다.","캐시-공급자#캐시 공급자":"캐시 공급자는 다음 TypeScript 정의와 일치하는 Map과 유사한 객체입니다(swr로부터 임포트할 수 있습니다).\ninterface Cache<Data> {\nget(key: string): Data | undefined\nset(key: string, value: Data): void\ndelete(key: string): void\n}\n예를 들어, JavaScript Map 인스턴스는 SWR을 위한 캐시 공급자로 직접 사용할 수 있습니다.","캐시-공급자-생성하기#캐시 공급자 생성하기":"SWRConfig의 provider 옵션은 캐시 공급자를 반환하는 함수를 받습니다. 그러면 공급자를 SWRConfig 경계 내의 모든 SWR hook에서 사용할 수 있습니다.\nimport useSWR, { SWRConfig } from 'swr'\n\nfunction App() {\nreturn (\n<SWRConfig value={{ provider: () => new Map() }}>\n<Page/>\n</SWRConfig>\n)\n}\n<Page/>내의 모든 SWR hook은 Map 인스턴스로부터 읽고 씁니다. 또한 특정 사례에 대해 다른 캐시 공급자 구현을 사용할 수도 있습니다.\n위 예시에서는 <App/> 컴포넌트가 다시 마운트될 때, 공급자 또한 다시 생성됩니다. 캐시 공급자는 컴포넌트 트리의 상위 또는 렌더링의 외부에 배치해야 합니다.\n\n\n\n\n중첩된 경우, SWR hook은 상위 레벨의 캐시 공급자를 사용합니다. 상위 레벨의 캐시 공급자가 존재하지 않을 경우, 빈 Map인 기본 캐시 공급자로 대체됩니다.\n캐시 공급자가 사용되는 경우, 전역 mutate는 <SWRConfig> 경계 내의 SWR hook에서 작동하지 않습니다. 대신에 이것을 사용하세요.","현재-캐시-공급자에-접근하기#현재 캐시 공급자에 접근하기":"React 컴포넌트 내에 있을 때, mutate를 포함해 다른 설정과 마찬가지로 현재 캐시 공급자에 접근하려면 useSWRConfig hook을 사용해야 합니다.\nimport { useSWRConfig } from 'swr'\n\nfunction Avatar() {\nconst { cache, mutate, ...extraConfig } = useSWRConfig()\n// ...\n}\n<SWRConfig> 아래에 존재하지 않는다면 기본 설정을 반환합니다.","실험적-캐시-공급자-확장하기#실험적: 캐시 공급자 확장하기":"실험적인 기능입니다. 향후 업그레이드에서 동작이 변경될 수 있습니다.\n여러 <SWRConfig> 컴포넌트가 중첩되어 있을 때, 캐시 공급자를 확장할 수 있습니다.provider 함수의 첫 번째 인자는 상위 레벨 <SWRConfig>(또는 부모 <SWRConfig>가 존재하지 않을 경우 기본 캐시)의 캐시 공급자입니다. 이를 사용해 캐시 공급자를 확장할 수 있습니다.\n<SWRConfig value={{ provider: (cache) => newCache }}>\n...\n</SWRConfig>","예시#예시":"","regex로-여러-키-변경하기#RegEx로 여러 키 변경하기":"캐시 공급자 API의 유연성으로, \"부분 변경\" 헬퍼를 구축할 수도 있습니다.아래 예시에서는 matchMutate가 정규 표현식을 키로 받고, 이 패턴에 일치하는 것들을 변경하는데 사용할 수 있습니다.\nfunction useMatchMutate() {\nconst { cache, mutate } = useSWRConfig()\nreturn (matcher, ...args) => {\nif (!(cache instanceof Map)) {\nthrow new Error('matchMutate requires the cache provider to be a Map instance')\n}\n\nconst keys = []\n\nfor (const key of cache.keys()) {\nif (matcher.test(key)) {\nkeys.push(key)\n}\n}\n\nconst mutations = keys.map((key) => mutate(key, ...args))\nreturn Promise.all(mutations)\n}\n}\n그 후 여러분의 컴포넌트 내에서:\nfunction Button() {\nconst matchMutate = useMatchMutate()\nreturn <button onClick={() => matchMutate(/^\\/api\\//)}>\nRevalidate all keys start with \"/api/\"\n</button>\n}\n\n이 예시는 캐시 공급자가 Map 인스턴스여야 합니다.","localstorage-기반-영구-캐시#LocalStorage 기반 영구 캐시":"캐시를 localStorage와 동기화하길 원할 수도 있습니다. 다음은 구현 예시입니다.\nfunction localStorageProvider() {\n// 초기화할 때, `localStorage`의 데이터를 map으로 복구합니다.\nconst map = new Map(JSON.parse(localStorage.getItem('app-cache') || '[]'))\n\n// app을 unloading하기 전에, 모든 데이터를 `localStorage`에 다시 씁니다.\nwindow.addEventListener('beforeunload', () => {\nconst appCache = JSON.stringify(Array.from(map.entries()))\nlocalStorage.setItem('app-cache', appCache)\n})\n\n// 성능을 위해 여전히 map을 사용해 쓰고 읽습니다.\nreturn map\n}\n그 후 이를 공급자로서 사용합니다.\n<SWRConfig value={{ provider: localStorageProvider }}>\n<App/>\n</SWRConfig>\n\n개선 사항으로, 메모리 캐시를 버퍼로 사용하고 주기적으로 localStorage에 쓸 수도 있습니다. IndexedDB 또는 WebSQL을 사용해 유사한 계층화된 캐시를 구현할 수도 있습니다.","테스트-케이스-간-캐시-초기화#테스트 케이스 간 캐시 초기화":"애플리케이션을 테스트할 때, 테스트 케이스 간 SWR 캐시를 초기화하길 원할 수도 있습니다. 간단하게 빈 캐시 공급자로 애플리케이션을 감싸면 됩니다. 다음은 Jest를 사용한 예시입니다.\ndescribe('test suite', async () => {\nit('test case', async () => {\nrender(\n<SWRConfig value={{ provider: () => new Map() }}>\n<App/>\n</SWRConfig>\n)\n})\n})","캐시에-접근하기#캐시에 접근하기":"알림: 캐시를 직접 쓰면 안 됩니다. 정의되지 않은 동작을 유발할 수도 있습니다.\nconst { cache } = useSWRConfig()\n\ncache.get(key) // 키에 대한 현재 데이터 가져오기.\ncache.clear()  // ⚠️ 모든 캐시를 삭제하기. SWR은 다시 렌더링할 때 재검증합니다."}},"/docs/advanced/performance":{"title":"성능","data":{"":"SWR은 모든 종류의 웹 앱에서 중요한 기능들을 제공하므로 성능을 가장 중요시합니다.SWR의 내장 캐싱과 중복 제거 기능은 불필요한 네트워크 요청을 생략하지만,\nuseSWR hook 자체의 성능은 여전히 중요합니다. 복잡한 앱에서는 단일 페이지 렌더링에 useSWR이 수백 번 호출될 수 있습니다.SWR은 앱에서 다음을 보장합니다:\n불필요한 요청 없음\n불필요한 리렌더링 없음\n불필요한 코드 임포트 없음\n\n어떠한 코드 수정도 필요 없습니다.","중복-제거#중복 제거":"앱에서 SWR hook을 재사용하는 것은 아주 일반적입니다. 예를 들어, 앱이 현재 사용자의 아바타를 다섯 번 렌더링한다면:\nfunction useUser () {\nreturn useSWR('/api/user', fetcher)\n}\n\nfunction Avatar () {\nconst { data, error } = useUser()\n\nif (error) return <Error />\nif (!data) return <Spinner />\n\nreturn <img src={data.avatar_url} />\n}\n\nfunction App () {\nreturn <>\n<Avatar />\n<Avatar />\n<Avatar />\n<Avatar />\n<Avatar />\n</>\n}\n각각의 <Avatar> 컴포넌트는 내부에 useSWR hook을 갖습니다. 이들이 동일한 SWR 키를 갖고 있으므로 거의 동시에 렌더링 되며 단 한 번의 네트워크 요청만 발생합니다.성능이나 중복된 요청에 대한 걱정 없이 위 예시의 useUser와 같은 데이터 hook을 어디에서든 재사용할 수 있습니다.기본 중복 제거 인터벌을 오버라이딩할 수 있는 dedupingInterval 옵션도 있습니다.","깊은-비교#깊은 비교":"SWR은 기본적으로 데이터 변경을 깊게 비교합니다. data 값이 변경되지 않았다면 리렌더링을 트리거 하지 않습니다.이 동작을 변경하길 원한다면 compare 옵션을 통해 비교 함수를 커스터마이징할 수도 있습니다.\n예를 들면, 일부 API의 응답이 데이터 diff에서 제외하길 원하는 서버의 타임 스탬프를 반환합니다.","의존성-수집#의존성 수집":"useSWR은 세 개의 스테이트풀 값을 반환합니다: data, error, isValidating, 각각은 독립적으로 업데이트됩니다.\n예를 들어, 전체 데이터 가져오기 생명 주기에서 이 값들을 출력한다면 뭔가 다음과 같은 것입니다.\nfunction App () {\nconst { data, error, isValidating } = useSWR('/api', fetcher)\nconsole.log(data, error, isValidating)\nreturn null\n}\n최악의 경우에는(첫 번째 요청이 실패하고, 재시도가 성공), 네 줄의 로그가 보일 것입니다.\n// console.log(data, error, isValidating)\nundefined undefined true  // => 가져오기 시작\nundefined Error false     // => 가져오기 종료, 에러 발생\nundefined Error true      // => 재시도 시작\nData undefined false      // => 재시도 종료, 데이터 얻음\n상태 변화는 말이 됩니다. 하지만 이는 컴포넌트가 네 번 리렌더링 되었음을 의미하기도 합니다.data만을 사용하도록 컴포넌트를 변경한다면:\nfunction App () {\nconst { data } = useSWR('/api', fetcher)\nconsole.log(data)\nreturn null\n}\n마법이 발생합니다 - 이제 단 두 번의 리렌더링이 있습니다:\n// console.log(data)\nundefined // => 하이드레이션 / 초기 렌더\nData      // => 재시도 종료, 데이터 얻음\n내부적으로는 완전히 동일한 과정이 발생했습니다. 첫 번째 요청에서 에러가 발생했고 재시도에서 데이터를 얻었습니다.\n그런데 SWR은 컴포넌트가 사용한 상태만을 업데이트하며, 이제는 data만 그렇습니다.이 모든 세 가지 상태를 항상 사용하고 있지 않다면, 이미 이 기능의 이점을 누리고 있는 것입니다.\nVercel에서, 이 최적화의 결과 ~60% 더 적은 리렌더링의 결과를 얻었습니다.","트리-쉐이킹#트리 쉐이킹":"SWR 패키지는 트리 쉐이킹이 가능하며 부작용도 없습니다.\n이는 코어 useSWR API만을 임포팅한다면 useSWRInfinite와 같은 사용하지 않는 API는 애플리케이션에 번들링되지 않는다는 것을 의미합니다."}},"/docs/advanced/react-native":{"title":"React Native","data":{"":"이 커스터마이재이션을 경험하시려면 최신 버전(≥ 1.0.0)으로 업그레이드하세요.\n브라우저 내에서 실행되는 React와 달리, React Native는 사용 환경이 매우 다릅니다. 예를 들면, \"tab focus\"가 없습니다. 대신에 백그라운드에서 앱으로 전환하는 것은 \"focus\"로 간주합니다.\n이러한 동작을 커스터마이징 하려면 기본 브라우저 focus와 online 이벤트 리스너를 React Native의 앱 상태 감지와 네이티브에서 이식된 다른 API로 교체하고, SWR이 사용하도록 설정해야 합니다.","예시#예시":"","전역-설치#전역 설치":"'SWRConfig' 아래의 앱을 감싸고 모든 설정을 미리 구성할 수 있습니다.\n<SWRConfig\nvalue={{\n/* ... */\n}}\n>\n<App>\n</SWRConfig>","focus-및-reconnect-이벤트-커스터마이징-하기#focus 및 reconnect 이벤트 커스터마이징 하기":"신경 써야 할 설정은 isOnline, isVisible, initFocus 및 initReconnect로 많지 않습니다.isOnline과 isVisible은 boolean을 반환하는 함수로, 애플리케이션이 \"active\"인지 여부를 확인합니다. 기본적으로 SWR은 이러한 조건들이 충족되지 않으면 재검증을 하지 않습니다.initFocus와 initReconnect을 사용할 때, 커스텀 캐시 공급자도 설정해야 합니다. 빈 Map() 또는 원하는 저장소를 사용하면 됩니다.\n<SWRConfig\nvalue={{\nprovider: () => new Map(),\nisOnline() {\n/* 네트워크 상태 감지자 커스터마이징 */\nreturn true\n},\nisVisible() {\n/* visibility 상태 감지자 커스터마이징 */\nreturn true\n},\ninitFocus(callback) {\n/* 상태 공급자에 리스너 등록 */\n},\ninitReconnect(callback) {\n/* 상태 공급자에 리스터 등록 */\n}\n}}\n>\n<App />\n</SWRConfig>\ninitFocus를 예로 들어보겠습니다.\nimport { AppState } from 'react-native'\n\n// ...\n\n<SWRConfig\nvalue={{\nprovider: () => new Map(),\nisVisible: () => { return true },\ninitFocus(callback) {\nlet appState = AppState.currentState\n\nconst onAppStateChange = (nextAppState) => {\n/* 백그라운드 또는 비활성 모드에서 활성 모드로 다시 시작하는 경우 */\nif (appState.match(/inactive|background/) && nextAppState === 'active') {\ncallback()\n}\nappState = nextAppState\n}\n\n// 앱 상태 변경 이벤트 구독\nconst subscription = AppState.addEventListener('change', onAppStateChange)\n\nreturn () => {\nsubscription.remove()\n}\n}\n}}\n>\n<App>\n</SWRConfig>\ninitReconnect의 경우, 네트워크 상태를 구독하려면 NetInfo와 같은 제3자 라이브러리가 필요합니다. 구현은 위 예시와 유사합니다. callback 함수를 받고 네트워크가 오프라인으로부터 복구될 때 이를 실행하여 SWR이 재검증을 시작하고 데이터를 최신으로 유지할 수 있습니다."}},"/examples/auth":{"title":"인증","data":{"":""}},"/examples/basic":{"title":"기본 사용법","data":{"":""}},"/examples/error-handling":{"title":"에러 처리","data":{"":""}},"/examples/infinite-loading":{"title":"인피니트 로딩","data":{"":""}}}
{"/docs/advanced/cache":{"title":"キャッシュ","data":{"":"この機能を使用するには、最新のバージョン（ ≥ 1.0.0 ）にアップグレードしてください。\n\nほとんどの場合、キャッシュを直接変更しないでください。予期しない動作が発生する可能性があります。キーを手動で変更する必要がある場合は、 SWR API の使用を検討してください。\n参照：ミューテーション, テストケース間のキャッシュのリセット\nデフォルトでは、 SWR はグローバルキャッシュを使用して、すべてのコンポーネント間でデータを保存および共有します。ただし、 SWRConfig の provider オプションを使用して、その挙動をカスタマイズできます。キャッシュプロバイダーは、よりカスタマイズされたストレージで SWR を実現することを目的としています。","キャッシュプロバイダー#キャッシュプロバイダー":"キャッシュプロバイダーは、次の TypeScript 定義（ swr からインポート可能 ）に一致する Map のようなオブジェクトです：\ninterface Cache<Data> {\nget(key: string): Data | undefined\nset(key: string, value: Data): void\ndelete(key: string): void\n}\nたとえば、JavaScript Map インスタンスを SWR のキャッシュプロバイダーとして直接使用できます。","キャッシュプロバイダーの作成#キャッシュプロバイダーの作成":"SWRConfig の provider オプションは、 キャッシュプロバイダーを返す関数を受け取ります。受け取ったプロバイダーは、その SWRConfig の範囲内のすべての SWR フックで使用されます。例：\nimport useSWR, { SWRConfig } from 'swr'\n\nfunction App() {\nreturn (\n<SWRConfig value={{ provider: () => new Map() }}>\n<Page/>\n</SWRConfig>\n)\n}\n<Page /> 内のすべての SWR フックは、その Map インスタンスから読み取りと書き込みを行います。また、特定のユースケースに合わせて、他のキャッシュプロバイダーの実装を使用することもできます。\n上記の例では、 <App /> コンポーネントが再マウントされると、プロバイダーも再生成します。キャッシュプロバイダーは、コンポーネントツリーの上位、またはレンダリングの外部に配置する必要があります。\n\n\n\n\nネストされている場合、 SWR フックは上位レベルのキャッシュプロバイダーを使用します。もし上位レベルのキャッシュプロバイダーが無い場合は、空の Map をデフォルトのキャッシュプロバイダーとして使用します。\nキャッシュプロバイダーを使用している場合、グローバルな mutate は <SWRConfig /> 以下の SWR フックでは機能しません。代わりに こちら を使用してください。","現在のキャッシュプロバイダーにアクセスする#現在のキャッシュプロバイダーにアクセスする":"React コンポーネント内では、 mutate を含む他の設定と同様に、現在のキャッシュプロバイダーへアクセスするために、 useSWRConfig フックを使用する必要があります。\nimport { useSWRConfig } from 'swr'\n\nfunction Avatar() {\nconst { cache, mutate, ...extraConfig } = useSWRConfig()\n// ...\n}\n<SWRConfig> 以下でない場合は、デフォルトの設定を返します。","実験的キャッシュプロバイダーの拡張#実験的：キャッシュプロバイダーの拡張":"これは実験的な機能であり、将来のアップグレードで動作が変更される可能性があります。\n複数の <SWRConfig> コンポーネントがネストされている場合、キャッシュプロバイダーを拡張できます。provider の最初の引数は、上位レベルの <SWRConfig> のキャッシュプロバイダー（ 親が <SWRConfig> でない場合はデフォルトのキャッシュ ）です。これを使用して、キャッシュプロバイダーを拡張できます：\n<SWRConfig value={{ provider: (cache) => newCache }}>\n...\n</SWRConfig>","例#例":"","正規表現から複数のキーを変更する#正規表現から複数のキーを変更する":"キャッシュプロバイダー API の柔軟性により、\"部分的な変更\"のヘルパーを構築することもできます。以下の例では、 matchMutate はキーとして正規表現を受け取り、パターンに一致するものを変更するために使用できます。\nfunction useMatchMutate() {\nconst { cache, mutate } = useSWRConfig()\nreturn (matcher, ...args) => {\nif (!(cache instanceof Map)) {\nthrow new Error('matchMutate requires the cache provider to be a Map instance')\n}\n\nconst keys = []\n\nfor (const key of cache.keys()) {\nif (matcher.test(key)) {\nkeys.push(key)\n}\n}\n\nconst mutations = keys.map((key) => mutate(key, ...args))\nreturn Promise.all(mutations)\n}\n}\n次に、コンポーネントの内部：\nfunction Button() {\nconst matchMutate = useMatchMutate()\nreturn <button onClick={() => matchMutate(/^\\/api\\//)}>\nRevalidate all keys start with \"/api/\"\n</button>\n}\n\nこの例では、キャッシュプロバイダーが Map インスタンスである必要があることに注意してください。","localstorage-を使った永続キャッシュ#LocalStorage を使った永続キャッシュ":"キャッシュを localStorage で同期しても良いかもしれません。実装例は次の通りです：\nfunction localStorageProvider() {\n// 初期化時に、 `localStorage` から Map にデータを復元します。\nconst map = new Map(JSON.parse(localStorage.getItem('app-cache') || '[]'))\n\n// アプリが終了する前に、すべてのデータを `localStorage` に保存します。\nwindow.addEventListener('beforeunload', () => {\nconst appCache = JSON.stringify(Array.from(map.entries()))\nlocalStorage.setItem('app-cache', appCache)\n})\n\n// パフォーマンスのために、書き込みと読み取りには引き続き Map を使用します。\nreturn map\n}\n次に、プロバイダーとして使用します：\n<SWRConfig value={{ provider: localStorageProvider }}>\n<App/>\n</SWRConfig>\n\n改善点として、メモリキャッシュをバッファとして使用し、定期的に localStorage に書き込むこともできます。 IndexedDB または WebSQL を使用して同様の階層化キャッシュを実装することもできます。","テストケース間のキャッシュのリセット#テストケース間のキャッシュのリセット":"アプリケーションをテストするときは、テストケース間で SWR キャッシュをリセットすることをオススメします。空のキャッシュプロバイダーでアプリケーションをラップするだけです。 Jest の例を次に示します：\ndescribe('test suite', async () => {\nit('test case', async () => {\nrender(\n<SWRConfig value={{ provider: () => new Map() }}>\n<App/>\n</SWRConfig>\n)\n})\n})","キャッシュへアクセスする#キャッシュへアクセスする":"警告：キャッシュに直接書き込むことはするべきではありません。予期しない動作が発生する可能性があります。\nconst { cache } = useSWRConfig()\n\ncache.get(key) // キーの現在のデータを取得します。\ncache.clear()  // ⚠️ すべてのキャッシュをクリアします。 SWRは、再レンダリング時に再検証します。"}},"/docs/advanced/performance":{"title":"パフォーマンス","data":{"":"SWR はあらゆる種類のウェブアプリで重要な機能を提供するため、パフォーマンスは最優先事項です。SWR に組み込まれたキャッシュと 重複排除 は、不要なネットワークリクエストをスキップしますが、useSWR フック自体の\nパフォーマンスは依然として重要です。複雑なアプリでは、useSWR はひとつのページのレンダリングで数百回の呼び出しが発生してしまう可能性があります。SWR は、アプリが次のようになっていることを確認します：\n不要なリクエストがないこと\n不要な再レンダリングがないこと\n不要なコードがインポートされていないこと\n\nこの確認のためにコードに変更を加える必要はありません。","重複排除#重複排除":"アプリ内で SWR フックを再利用することは非常に一般的です。たとえば、現在のユーザーのアバターを 5 回レンダリングするアプリを考えてみましょう：\nfunction useUser () {\nreturn useSWR('/api/user', fetcher)\n}\n\nfunction Avatar () {\nconst { data, error } = useUser()\n\nif (error) return <Error />\nif (!data) return <Spinner />\n\nreturn <img src={data.avatar_url} />\n}\n\nfunction App () {\nreturn <>\n<Avatar />\n<Avatar />\n<Avatar />\n<Avatar />\n<Avatar />\n</>\n}\n各 <Avatar> コンポーネントは内部的に useSWR フックを使用しています。それらは同じ SWR キーを持ち、ほぼ同時にレンダリングされるため、たった一度のネットワークリクエストのみが行われます。パフォーマンスや重複したリクエストを心配することなく、どこでも（上記の例にあった useUser のように）データフックを再利用できます。デフォルトの重複排除間隔を上書きする dedupingInterval オプションもあります。","詳細な比較#詳細な比較":"SWR は、デフォルトでデータの変更を詳細に比較します。data という値が変更されていない場合、再レンダリングは開始されません。動作を変更したい場合は、compare オプションを使用して比較機能をカスタマイズすることもできます。\nたとえば、一部の API レスポンスは、データ差分から除外したいサーバーのタイムスタンプを返します。","依存関係のコレクション#依存関係のコレクション":"useSWR が返す三つのステートフルな値、つまり data 、error 、そして isValidating は、それぞれが独立して更新されます。\nたとえば、完全なデータフェッチのライフサイクル内でこれらの値を出力すると次のようになります：\nfunction App () {\nconst { data, error, isValidating } = useSWR('/api', fetcher)\nconsole.log(data, error, isValidating)\nreturn null\n}\n最悪の場合（最初のリクエストが失敗し、次に再試行が成功した場合）には、4 行のログが表示されます：\n// console.log(data, error, isValidating)\nundefined undefined true  // => フェッチの開始\nundefined Error false     // => フェッチの完了、エラーを取得\nundefined Error true      // => 再試行の開始\nData undefined false      // => 再試行の完了、データを取得\nこの状態変化は理にかなっています。しかし、それはまた、コンポーネントが 4 回レンダリングされることを意味します。コンポーネントを変更して data だけを使用する場合：\nfunction App () {\nconst { data } = useSWR('/api', fetcher)\nconsole.log(data)\nreturn null\n}\n魔法が起こります — 今回は二つの再レンダリングしかありません：\n// console.log(data)\nundefined // => 再利用 / 初期レンダリング\nData      // => 再試行の完了、データを取得\nまったく同じプロセスが内部で発生して、最初のリクエストでエラーが発生し、再試行でデータを取得しました。\nただし、SWR はコンポーネントによって使用されている状態のみを更新します、つまり今回は data だけです。これら三つの状態すべてを常に使用しているわけではない場合は、すでにこの機能の恩恵を受けています。\nVercel では、この最適化により再レンダリングが最大 60% 少なくなります。","ツリーシェイク#ツリーシェイク":"SWR パッケージは、ツリーシェイク可能で副作用がありません。\nつまり、コアな useSWR API のみをインポートする場合、useSWRInfinite のような未使用の API はアプリケーションにバンドルされません。"}},"/docs/advanced/react-native":{"title":"React Native","data":{"":"このカスタマイズを体験するには、最新バージョン（ ≥ 1.0.0 ）にアップグレードしてください。\nブラウザ内で実行されている React とは異なり、React Native の使用体験は大きく異なります。たとえば、“タブフォーカス”はなく、バックグラウンドからアプリの切り替えは“フォーカス”とみなされます。\nこれらの動作をカスタマイズするには、デフォルトの focus と online のイベントリスナーを React Native のアプリの状態検出や、その他のネイティブ移植 API に置き換えて使用するように SWR を構成します。","例#例":"","グローバル設定#グローバル設定":"アプリを SWRConfig でラップし、すべての構成を事前に設定できます。\n<SWRConfig\nvalue={{\n/* ... */\n}}\n>\n<App>\n</SWRConfig>","focus-と-reconnect-イベントのカスタマイズ#focus と reconnect イベントのカスタマイズ":"isOnline 、 isVisible 、 initFocus 、 initReconnect など、いくつかの設定を行う必要があります。isOnline と isVisible は、アプリケーションが\"アクティブ\"であるかどうかを判断するための真偽値を返す関数です。デフォルトでは、これらの条件が満たされてない場合、 SWR は再検証を中止します。initFocus と initReconnect を使用する場合は、カスタムキャッシュプロバイダーも設定する必要があります。空の Map() 、または任意のストレージを使用できます。\n<SWRConfig\nvalue={{\nprovider: () => new Map(),\nisOnline() {\n/* ネットワーク状態の検出器をカスタマイズ */\nreturn true\n},\nisVisible() {\n/* 視認状態の検出器をカスタマイズ */\nreturn true\n},\ninitFocus(callback) {\n/* リスナーをステートプロバイダーに登録 */\n},\ninitReconnect(callback) {\n/* リスナーをステートプロバイダーに登録 */\n}\n}}\n>\n<App />\n</SWRConfig>\nここでは、 initFocus を例に説明します：\nimport { AppState } from 'react-native'\n\n// ...\n\n<SWRConfig\nvalue={{\nprovider: () => new Map(),\nisVisible: () => { return true },\ninitFocus(callback) {\nlet appState = AppState.currentState\n\nconst onAppStateChange = (nextAppState) => {\n/* バックグラウンドモードまたは非アクティブモードからアクティブモードに再開する場合 */\nif (appState.match(/inactive|background/) && nextAppState === 'active') {\ncallback()\n}\nappState = nextAppState\n}\n\n// アプリの状態変更を監視する\nconst subscription = AppState.addEventListener('change', onAppStateChange)\n\nreturn () => {\nsubscription.remove()\n}\n}\n}}\n>\n<App>\n</SWRConfig>\ninitReconnect の場合、ネットワーク状態を監視するには NetInfo などのサードパーティ製のライブラリが必要です。実装は上記の例と同様です： callback 関数を受け取り、ネットワークがオフラインから復帰したときに実行するため、 SWR は再検証を開始してデータを最新の状態に保つことができます。"}},"/examples/auth":{"title":"認証","data":{"":""}},"/examples/basic":{"title":"基本的な使用法","data":{"":""}},"/examples/error-handling":{"title":"エラーハンドリング","data":{"":""}},"/examples/infinite-loading":{"title":"無限ローディング","data":{"":""}}}